# plugins/verify_plugin.py
import os
import time
import io
import csv
import traceback
from typing import Optional

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.error import ChatMigrated, TelegramError, BadRequest
from telegram.ext import (
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ChatMemberHandler,
    filters,
)

from . import db
from . import utils
from .active_time_plugin import require_active, register_background_tasks

# Config (read env and persisted verify id)
BOT_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_ID = int(os.getenv("ADMIN_ID", "0"))
_DEFAULT_VERIFY_CHAT_ID = os.getenv("VERIFY_CHAT_ID")
VERIFY_CHAT_ID = db.get_verify_chat_id() or (int(_DEFAULT_VERIFY_CHAT_ID) if _DEFAULT_VERIFY_CHAT_ID else None)

# Tunables
RATE_LIMIT_SECONDS = 30
MAX_ATTEMPTS = 2
SESSION_TTL = 5 * 60
INVITE_TTL = 2 * 60
INVITE_CLEANUP_INTERVAL = 5 * 60

# Templates
DEFAULT_TEMPLATES = {
    "msg_verified": "Verified — here's your one-time invite link (expires in {minutes} minutes):\n\n{link}",
    "msg_auto_fail_user": "Verified — auto-approve failed due to a system error. Admins have been notified and will review your request.",
    "msg_approved": "Approved — here's your one-time invite link (expires in {minutes} minutes):\n\n{link}",
    "msg_rejected": "Sorry, your verification was rejected by admin. You can try /start again.",
    "msg_whitelisted": "You have been whitelisted by the admin and can join the group.",
    "msg_banned": "You have been banned from verification by the admin.",
}

def get_template(key: str):
    v = db.load_setting(key)
    return v if v is not None else DEFAULT_TEMPLATES.get(key, "")

def _persist_verify_chat_id(cid: int):
    global VERIFY_CHAT_ID
    VERIFY_CHAT_ID = int(cid)
    db.set_verify_chat_id(VERIFY_CHAT_ID)
    db.log_event(0, 0, "chat_migrated", f"verify_chat_id updated to {VERIFY_CHAT_ID}")

# Robust send to verify chat (handles ChatMigrated)
async def send_to_verify_chat(bot, text, reply_markup=None, parse_mode=None):
    global VERIFY_CHAT_ID
    try:
        return await bot.send_message(chat_id=VERIFY_CHAT_ID, text=text, reply_markup=reply_markup, parse_mode=parse_mode)
    except ChatMigrated as e:
        new_id = getattr(e, "migrate_to_chat_id", None)
        if new_id is None:
            try:
                new_id = int(str(e).split()[-1])
            except Exception:
                db.log_event(0, 0, "chat_migrate_parse_fail", str(e))
                raise
        _persist_verify_chat_id(new_id)
        try:
            return await bot.send_message(chat_id=VERIFY_CHAT_ID, text=text, reply_markup=reply_markup, parse_mode=parse_mode)
        except TelegramError as e2:
            db.log_event(0, 0, "admin_send_failed_after_migrate", str(e2))
            return None
    except TelegramError as e:
        db.log_event(0, 0, "admin_send_failed", str(e))
        return None

# Invite creation with ChatMigrated handling
async def create_one_time_invite(bot, chat_id: int, member_limit: int = 1, ttl: int = INVITE_TTL):
    global VERIFY_CHAT_ID
    try:
        invite = await bot.create_chat_invite_link(
            chat_id=chat_id,
            member_limit=member_limit,
            expire_date=db.now_ts() + ttl,
        )
        return invite
    except ChatMigrated as e:
        new_id = getattr(e, "migrate_to_chat_id", None)
        if new_id is None:
            try:
                new_id = int(str(e).split()[-1])
            except Exception:
                db.log_event(0, 0, "create_invite_migrate_parse_fail", str(e))
                raise
        _persist_verify_chat_id(new_id)
        invite = await bot.create_chat_invite_link(
            chat_id=VERIFY_CHAT_ID,
            member_limit=member_limit,
            expire_date=db.now_ts() + ttl,
        )
        return invite

# Admin action keyboard
def admin_action_kb(uid: int):
    return InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("Approve", callback_data=f"approve:{uid}"),
                InlineKeyboardButton("Reject", callback_data=f"reject:{uid}"),
            ],
            [
                InlineKeyboardButton("Whitelist", callback_data=f"whitelist:{uid}"),
                InlineKeyboardButton("Ban", callback_data=f"ban:{uid}"),
            ],
            [
                InlineKeyboardButton("Invite history", callback_data=f"invhist:{uid}"),
                InlineKeyboardButton("Invite history CSV", callback_data=f"invhist_csv:{uid}"),
            ],
        ]
    )

# Revoke helpers that call Telegram
async def revoke_invite(bot, invite_link: str, chat_id: int, revoked_by: int = None):
    try:
        await bot.revoke_chat_invite_link(chat_id=chat_id, invite_link=invite_link)
        db.mark_invite_revoked(invite_link, revoked_by=revoked_by)
        db.log_event(0, revoked_by or 0, "invite_revoked", invite_link)
        return True
    except TelegramError as e:
        err = str(e)
        db.log_event(0, 0, "revoke_failed", err)
        if "INVITE_LINK" in err.upper() or "NOT FOUND" in err.upper() or "invalid" in err.lower():
            db.mark_invite_revoked(invite_link, revoked_by=revoked_by)
            return True
        return False

async def revoke_all_other_invites_for_user(bot, uid: int, exclude_link: str = None, revoked_by: int = None):
    others = db.get_other_unrevoked_invites_for_user(uid, exclude_link)
    for rec in others:
        _, link, chat_id = rec
        try:
            await revoke_invite(bot, link, chat_id, revoked_by=revoked_by)
        except Exception as e:
            db.log_event(uid, revoked_by or 0, "revoke_other_failed", str(e))

# Invite cleanup loop
async def invite_cleanup_loop(app):
    bot = app.bot
    while True:
        now = db.now_ts()
        rows = db.get_expired_unrevoked_invites(now)
        for r in rows:
            _, link, chat_id = r
            try:
                await revoke_invite(bot, link, chat_id)
            except Exception as e:
                db.log_event(0, 0, "invite_cleanup_exception", str(e))
        await asyncio_sleep(INVITE_CLEANUP_INTERVAL)

# Small compatibility wrapper for sleeping that works inside PTB context
async def asyncio_sleep(seconds: int):
    # simple wrapper to avoid importing asyncio at top-level in some contexts
    import asyncio as _asyncio
    await _asyncio.sleep(seconds)

# Permission check at startup
async def check_startup_permissions(app):
    bot = app.bot
    if VERIFY_CHAT_ID is None:
        db.log_event(0, 0, "perm_missing", "VERIFY_CHAT_ID not set")
        return
    try:
        me = await bot.get_me()
        member = await bot.get_chat_member(chat_id=VERIFY_CHAT_ID, user_id=me.id)
    except Exception as e:
        db.log_event(0, 0, "startup_perm_check_failed", str(e))
        try:
            await send_to_verify_chat(bot, f"Warning: failed to check bot permissions: {e}", parse_mode=None)
        except Exception:
            pass
        return

    is_admin = getattr(member, "status", "") in ("administrator", "creator")
    can_invite = bool(getattr(member, "can_invite_users", False) or getattr(member, "can_manage_chat", False))
    if not is_admin or not can_invite:
        note = f"Startup permission warning: bot admin/invite rights missing in verify chat (id {VERIFY_CHAT_ID}). Auto-approve may fail."
        db.log_event(0, 0, "perm_missing", note)
        try:
            await bot.send_message(chat_id=ADMIN_ID, text=note)
        except Exception:
            pass
        try:
            await send_to_verify_chat(bot, note, parse_mode=None)
        except Exception:
            pass

# Handlers
async def start(update: Update, context):
    user = update.effective_user⁷
    uid = user.id
    if db.is_banned(uid):
        await update.message.reply_text("You are banned from verification. Contact an admin if this is a mistake.")
        db.log_event(uid, 0, "start_blocked_banned", "")
        return
    if db.is_whitelisted(uid):
        await update.message.reply_text("You are already whitelisted. Use your normal account to join the group.")
        db.log_event(uid, 0, "start_blocked_whitelisted", "")
        return
    now = db.now_ts()
    s = db.get_session(uid)
    if s and (now - s[4]) < RATE_LIMIT_SECONDS:
        wait = RATE_LIMIT_SECONDS - (now - s[4])
        await update.message.reply_text(f"Please wait {wait} more seconds before requesting a new captcha.")
        return

    chosen, options = utils.gen_emoji_challenge()
    db.save_session(uid, chosen, "awaiting_captcha", attempts=0, ttl=SESSION_TTL)

    row = [InlineKeyboardButton(opt, callback_data=f"captcha:{opt}:{uid}") for opt in options]
    kb = InlineKeyboardMarkup([row])

    await update.message.reply_text(
        f"Solve this captcha by clicking the matching emoji button below.\n\nSelect the emoji that matches this token: {chosen}",
        reply_markup=kb,
    )
    db.log_event(uid, 0, "start_sent_captcha_inline", "options=" + " ".join(options))

async def callback_handler(update: Update, context):
    q = update.callback_query
    await q.answer()
    data = q.data or ""

    if data.startswith("captcha:"):
        _, picked, uid_s = data.split(":", 2)
        try:
            uid = int(uid_s)
        except ValueError:
            await q.edit_message_text("Invalid captcha data.")
            return

        if q.from_user.id != uid:
            await q.answer("This captcha is not for you.", show_alert=True)
            return

        s = db.get_session(uid)
        if not s or s[2] != "awaiting_captcha":
            await q.edit_message_text((q.message.text or "") + "\n\nNo active captcha (maybe expired). Send /start to try again.")
            return
        _, answer, _, _, _, expires_at = s
        if db.now_ts() > expires_at:
            db.del_session(uid)
            await q.edit_message_text((q.message.text or "") + "\n\nCaptcha expired. Send /start to try again.")
            return

        if picked == answer:
            try:
                invite = await create_one_time_invite(context.bot, VERIFY_CHAT_ID, member_limit=1, ttl=INVITE_TTL)
                link = invite.invite_link
                db.del_session(uid)
                db.store_invite(link, VERIFY_CHAT_ID, db.now_ts() + INVITE_TTL, user_id=uid, approved_by=0)
                await revoke_all_other_invites_for_user(context.bot, uid, exclude_link=link, revoked_by=0)
                escaped = utils.escape_md_v2(link)
                tpl = get_template("msg_verified")
                text = tpl.format(link=f"||{escaped}||", minutes=INVITE_TTL//60)
                try:
                    await context.bot.send_message(chat_id=uid, text=text, parse_mode="MarkdownV2")
                except BadRequest as bre:
                    db.log_event(uid, 0, "markdownv2_send_failed", str(bre))
                    await context.bot.send_message(chat_id=uid, text=get_template("msg_verified").format(link=link, minutes=INVITE_TTL//60))
                await q.edit_message_text((q.message.text or "") + "\n\nCaptcha correct. Invite sent to your DM.")
                db.log_event(uid, 0, "auto_approved", f"invite_sent ttl={INVITE_TTL}")
            except Exception as e:
                err = str(e)
                db.log_event(uid, 0, "auto_approve_failed", err)
                db.save_session(uid, answer, "pending_admin", attempts=0, ttl=SESSION_TTL)
                caption = (
                    f"Verification request (auto-approve failed): @{q.from_user.username or 'no_username'} (id {uid})\n\n"
                    f"Auto-approve failed with error:\n{err}\n\nPlease approve or reject."
                )
                kb = admin_action_kb(uid)
                try:
                    await send_to_verify_chat(context.bot, caption, reply_markup=kb, parse_mode=None)
                except Exception as e2:
                    db.log_event(uid, 0, "admin_notify_fail_after_auto_fail", str(e2))
                await context.bot.send_message(chat_id=uid, text=get_template("msg_auto_fail_user"))
                await q.edit_message_text((q.message.text or "") + "\n\nCaptcha correct but auto-approve failed; admins notified.")
            return
        else:
            attempts = db.inc_attempt(uid)
            if attempts >= MAX_ATTEMPTS:
                caption = f"User @{q.from_user.username or 'no_username'} (id {uid}) failed captcha {attempts} times and requires manual review."
                kb = admin_action_kb(uid)
                try:
                    await send_to_verify_chat(context.bot, caption, reply_markup=kb)
                except Exception as e:
                    db.log_event(uid, 0, "escalation_notify_fail", str(e))
                db.del_session(uid)
                await q.edit_message_text((q.message.text or "") + "\n\nToo many failed attempts — admins have been notified.")
                db.log_event(uid, 0, "captcha_escalated", f"attempts={attempts}")
            else:
                await q.edit_message_text((q.message.text or "") + f"\n\nIncorrect. You have {MAX_ATTEMPTS - attempts} attempts left. Send /start to try again.")
                db.log_event(uid, 0, "captcha_fail_inline", f"attempts={attempts}")
            return

    if ":" not in data:
        await q.answer("Unknown action.")
        return

    parts = data.split(":", 2)
    action = parts[0]
    try:
        uid = int(parts[1])
    except ValueError:
        await q.edit_message_text(text=(q.message.text or "") + "\n\nInvalid callback data.")
        return

    if q.from_user.id != ADMIN_ID:
        await q.answer("Only the configured admin may use these buttons.", show_alert=True)
        return

    # Approve
    if action == "approve":
        try:
            invite = await create_one_time_invite(context.bot, VERIFY_CHAT_ID, member_limit=1, ttl=INVITE_TTL)
            link = invite.invite_link
            db.store_invite(link, VERIFY_CHAT_ID, db.now_ts() + INVITE_TTL, user_id=uid, approved_by=q.from_user.id)
            await revoke_all_other_invites_for_user(context.bot, uid, exclude_link=link, revoked_by=q.from_user.id)
        except Exception as e:
            await q.edit_message_text(text=(q.message.text or "") + f"\n\nApproval failed: {e}")
            db.log_event(uid, ADMIN_ID, "approve_fail", str(e))
            return
        db.del_session(uid)
        escaped = utils.escape_md_v2(link)
        tpl = get_template("msg_approved")
        text = tpl.format(link=f"||{escaped}||", minutes=INVITE_TTL//60)
        try:
            await context.bot.send_message(chat_id=uid, text=text, parse_mode="MarkdownV2")
        except BadRequest as bre:
            db.log_event(uid, ADMIN_ID, "markdownv2_send_failed_adminflow", str(bre))
            await context.bot.send_message(chat_id=uid, text=get_template("msg_approved").format(link=link, minutes=INVITE_TTL//60))

        await q.edit_message_text(text=(q.message.text or "") + f"\n\nApproved. Invite sent to user.")
        db.log_event(uid, ADMIN_ID, "approved", "")

    elif action == "reject":
        db.del_session(uid)
        await context.bot.send_message(chat_id=uid, text=get_template("msg_rejected"))
        await q.edit_message_text(text=(q.message.text or "") + "\n\nRejected by admin.")
        db.log_event(uid, ADMIN_ID, "rejected", "")

    elif action == "whitelist":
        db.set_whitelist(uid, True, ADMIN_ID, note="whitelisted via admin button")
        await q.edit_message_text(text=(q.message.text or "") + "\n\nUser whitelisted by admin.")
        await context.bot.send_message(chat_id=uid, text=get_template("msg_whitelisted"))

    elif action == "ban":
        db.set_ban(uid, True, ADMIN_ID, note="banned via admin button")
        db.del_session(uid)
        await q.edit_message_text(text=(q.message.text or "") + "\n\nUser banned by admin.")
        await context.bot.send_message(chat_id=uid, text=get_template("msg_banned"))

    elif action == "manual":
        await q.edit_message_text(text=(q.message.text or "") + "\n\nAdmin requested manual verification.")
        db.log_event(uid, ADMIN_ID, "manual_review_requested", "")

    elif action == "invhist":
        rows = db.get_all_invites_for_user(uid, limit=200)
        if not rows:
            await q.answer("No invites found for that user.", show_alert=True)
            return
        out = []
        for r in rows:
            iid, link, chat_id, created_at, expires_at, revoked, approved_by, revoked_by = r
            created_s = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(created_at))
            expires_s = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(expires_at))
            out.append(f"id={iid} | revoked={revoked} | created={created_s} | expires={expires_s} | approved_by={approved_by} | revoked_by={revoked_by} | link={link}")
        text = "\n".join(out)
        if len(text) <= 1000:
            await q.answer(text, show_alert=True)
        else:
            for chunk_start in range(0, len(text), 4000):
                await context.bot.send_message(chat_id=ADMIN_ID, text=text[chunk_start:chunk_start+4000])
            await q.answer("Invite history sent to admin chat.", show_alert=True)

    elif action == "invhist_csv":
        rows = db.get_all_invites_for_user(uid, limit=2000)
        if not rows:
            await q.answer("No invites found for that user.", show_alert=True)
            return
        out_io = io.StringIO()
        writer = csv.writer(out_io)
        writer.writerow(["id", "invite_link", "chat_id", "created_at", "expires_at", "revoked", "approved_by", "revoked_by"])
        for r in rows:
            iid, link, chat_id, created_at, expires_at, revoked, approved_by, revoked_by = r
            writer.writerow([iid, link, chat_id, created_at, expires_at, revoked, approved_by, revoked_by])
        csv_text = out_io.getvalue()
        out_io.close()
        for chunk_start in range(0, len(csv_text), 4000):
            await context.bot.send_message(chat_id=ADMIN_ID, text=csv_text[chunk_start:chunk_start+4000])
        await q.answer("CSV invite history sent to admin chat.", show_alert=True)

    else:
        await q.answer("Unknown action.")

# Admin command handlers (full implementations copied from original)
async def cmd_approve(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /approve <user_id>")
        return
    uid = int(context.args[0])
    s = db.get_session(uid)
    if s is None:
        await update.message.reply_text("No pending session for that user.")
        return
    try:
        invite = await create_one_time_invite(context.bot, VERIFY_CHAT_ID, member_limit=1, ttl=INVITE_TTL)
        link = invite.invite_link
        db.store_invite(link, VERIFY_CHAT_ID, db.now_ts() + INVITE_TTL, user_id=uid, approved_by=update.effective_user.id)
        await revoke_all_other_invites_for_user(context.bot, uid, exclude_link=link, revoked_by=update.effective_user.id)
    except Exception as e:
        await update.message.reply_text(f"Invite creation failed: {e}")
        db.log_event(uid, ADMIN_ID, "approve_cmd_invite_fail", str(e))
        return
    db.del_session(uid)
    tpl = get_template("msg_approved")
    escaped = utils.escape_md_v2(link)
    text = tpl.format(link=f"||{escaped}||", minutes=INVITE_TTL//60)
    try:
        await context.bot.send_message(chat_id=uid, text=text, parse_mode="MarkdownV2")
    except BadRequest:
        await context.bot.send_message(chat_id=uid, text=get_template("msg_approved").format(link=link, minutes=INVITE_TTL//60))
    await update.message.reply_text(f"Approved {uid} and invite sent.")
    db.log_event(uid, ADMIN_ID, "approved_cmd", "")

async def cmd_reject(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /reject <user_id>")
        return
    uid = int(context.args[0])
    db.del_session(uid)
    await context.bot.send_message(chat_id=uid, text=get_template("msg_rejected"))
    await update.message.reply_text(f"Rejected {uid}.")
    db.log_event(uid, ADMIN_ID, "rejected_cmd", "")

async def cmd_pending(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    rows = db.list_pending_sessions(100)
    if not rows:
        await update.message.reply_text("No pending sessions.")
        return
    out = []
    for r in rows:
        ts = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(r[1]))
        out.append(f"uid={r[0]} started={ts}")
    await update.message.reply_text("\n".join(out))

async def cmd_stats(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    total_attempts = db.cursor.execute("SELECT COUNT(*) FROM logs WHERE event_type LIKE 'attempt_inc'").fetchone()[0]
    total_approved = db.cursor.execute("SELECT COUNT(*) FROM logs WHERE event_type='approved'").fetchone()[0]
    total_banned = db.cursor.execute("SELECT COUNT(*) FROM logs WHERE event_type='ban'").fetchone()[0]
    pending = db.cursor.execute("SELECT COUNT(*) FROM sessions WHERE state='pending_admin'").fetchone()[0]
    await update.message.reply_text(f"attempts={total_attempts} approved={total_approved} banned={total_banned} pending={pending}")

async def cmd_setmsg(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    if len(context.args) < 2:
        await update.message.reply_text("Usage: /setmsg <key> <text>\nKeys: msg_verified, msg_auto_fail_user, msg_approved, msg_rejected, msg_whitelisted, msg_banned")
        return
    key = context.args[0]
    text = " ".join(context.args[1:])
    db.save_setting(key, text)
    await update.message.reply_text(f"Saved template {key}.")

async def cmd_invitehistory(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /invitehistory <user_id> or /invitehistory csv <user_id>")
        return
    if context.args[0].lower() == "csv" and len(context.args) >= 2:
        uid = int(context.args[1])
        rows = db.get_all_invites_for_user(uid, limit=2000)
        if not rows:
            await update.message.reply_text("No invites found for that user.")
            return
        out_io = io.StringIO()
        writer = csv.writer(out_io)
        writer.writerow(["id", "invite_link", "chat_id", "created_at", "expires_at", "revoked", "approved_by", "revoked_by"])
        for r in rows:
            iid, link, chat_id, created_at, expires_at, revoked, approved_by, revoked_by = r
            writer.writerow([iid, link, chat_id, created_at, expires_at, revoked, approved_by, revoked_by])
        csv_text = out_io.getvalue()
        out_io.close()
        for chunk_start in range(0, len(csv_text), 4000):
            await update.message.reply_text(csv_text[chunk_start:chunk_start+4000])
        return
    uid = int(context.args[0])
    rows = db.get_all_invites_for_user(uid, limit=200)
    if not rows:
        await update.message.reply_text("No invites found for that user.")
        return
    out = []
    for r in rows:
        iid, link, chat_id, created_at, expires_at, revoked, approved_by, revoked_by = r
        created_s = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(created_at))
        expires_s = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(expires_at))
        out.append(f"id={iid} | revoked={revoked} | created={created_s} | expires={expires_s} | approved_by={approved_by} | revoked_by={revoked_by} | link={link}")
    text = "\n".join(out)
    for chunk_start in range(0, len(text), 4000):
        await update.message.reply_text(text[chunk_start:chunk_start+4000])


async def cmd_whitelist(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    args = context.args
    if not args:
        await update.message.reply_text("Usage: /whitelist <user_id>")
        return
    uid = int(args[0])
    db.set_whitelist(uid, True, ADMIN_ID, note="whitelisted via command")
    await update.message.reply_text(f"Whitelisted {uid}.")

async def cmd_unwhitelist(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    args = context.args
    if not args:
        await update.message.reply_text("Usage: /unwhitelist <user_id>")
        return
    uid = int(args[0])
    db.set_whitelist(uid, False, ADMIN_ID, note="unwhitelisted via command")
    await update.message.reply_text(f"Unwhitelisted {uid}.")

async def cmd_ban(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    args = context.args
    if not args:
        await update.message.reply_text("Usage: /ban <user_id>")
        return
    uid = int(args[0])
    db.set_ban(uid, True, ADMIN_ID, note="banned via command")
    await update.message.reply_text(f"Banned {uid}.")

async def cmd_unban(update: Update, context):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("Not allowed.")
        return
    args = context.args
    if not args:
        await update.message.reply_text("Usage: /unban <user_id>")
        return
    uid = int(args[0])
    db.set_ban(uid, False, ADMIN_ID, note="unbanned via command")
    await update.message.reply_text(f"Unbanned {uid}.")

async def chat_member_update(update: Update, context):
    chat = update.chat_member.chat
    if VERIFY_CHAT_ID is None or chat.id != VERIFY_CHAT_ID:
        return
    new_status = update.chat_member.new_chat_member.status
    if new_status == "member":
        user = update.chat_member.new_chat_member.user
        uid = user.id
        rec = db.get_unrevoked_invite_for_user(uid)
        if rec:
            _, link, chat_id = rec
            try:
                await revoke_invite(context.bot, link, chat_id, revoked_by=0)
            except Exception as e:
                db.log_event(uid, 0, "revoke_on_join_failed", str(e))
            try:
                await revoke_all_other_invites_for_user(context.bot, uid, exclude_link=link, revoked_by=0)
            except Exception as e:
                db.log_event(uid, 0, "revoke_other_on_join_failed", str(e))

# Global error handler
# To-Do List 3...

# Register function to add handlers to app
def register(app):
    # user flows
    app.add_handler(CommandHandler("start", require_active(start)))
    app.add_handler(CallbackQueryHandler(require_active(callback_handler)))
    app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), lambda u, c: u.message.reply_text("Send /start to begin verification.")))
    # chat member updates - detect joins
    app.add_handler(ChatMemberHandler(chat_member_update, chat_member_types=ChatMemberHandler.CHAT_MEMBER))

    # admin commands
    app.add_handler(CommandHandler("approve", cmd_approve))
    app.add_handler(CommandHandler("reject", cmd_reject))
    app.add_handler(CommandHandler("pending", cmd_pending))
    app.add_handler(CommandHandler("stats", cmd_stats))
    app.add_handler(CommandHandler("setmsg", cmd_setmsg))
    app.add_handler(CommandHandler("invitehistory", cmd_invitehistory))
    app.add_handler(CommandHandler("whitelist", cmd_whitelist))
    app.add_handler(CommandHandler("unwhitelist", cmd_unwhitelist))
    app.add_handler(CommandHandler("ban", cmd_ban))
    app.add_handler(CommandHandler("unban", cmd_unban))

# create our startup coroutine
    async def _our_post_startup(application):
        await check_startup_permissions(application)
        application.create_task(invite_cleanup_loop(application))

    # Normalize and merge with any existing post_init (it may be None, a coroutine/coro-func, or a list)
    existing = getattr(app, "post_init", None)

    if existing is None:
        # app expects a coroutine (or coroutine function); provide one
        app.post_init = _our_post_startup
    else:
        # build a wrapper coroutine that awaits the existing behavior then ours
        async def _merged_post_init(application):
            # If existing is a list of callables/coroutines, run them sequentially
            if isinstance(existing, list):
                for item in existing:
                    if callable(item):
                        maybe = item(application)
                        if hasattr(maybe, "__await__"):
                            await maybe
                    elif hasattr(item, "__await__"):
                        await item
                # fall through to run ours
            else:
                # existing might be a coroutine function or coroutine object
                if callable(existing):
                    maybe = existing(application)
                    if hasattr(maybe, "__await__"):
                        await maybe
                elif hasattr(existing, "__await__"):
                    await existing
            # now run our startup tasks
            await _our_post_startup(application)

        app.post_init = _merged_post_init
    # register active_time plugin background tasks (if any)
    register_background_tasks(app)
